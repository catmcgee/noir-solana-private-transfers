# Step 0: Introduction - Teleprompter Script

## Opening (From Escrow to Private Pool)

You just built an escrow program. It holds funds and releases them when conditions are met.

Now we're going to build something that looks similar on the surface - it's a pool that holds funds. But with one crucial difference: privacy.

Let's think about what your escrow looked like from the outside.

The maker created an escrow. That transaction was visible. Their public key, the amount, the mint - all on-chain, all public.

The taker came along and completed the trade. Again, visible. Their public key stored right there in the escrow account.

Anyone running a Solana explorer could see exactly who traded with whom. And for many applications, that's totally fine. But for others? It's a problem.

---

## The Privacy Problem

Imagine you're a business paying contractors. Every payment is visible. Your competitors can see who you're working with. Your contractors can see what you're paying others.

Or imagine you're a donor to a controversial cause. Maybe you support something that's legal but sensitive. Everyone can see your wallet activity.

Or even simpler - you just don't want your financial history to be a public database that anyone can query.

This is where privacy technology comes in.

---

## What We're Building

We're building a private pool. The concept is simple.

Users deposit SOL into a shared pool. Later, users can withdraw from that pool. And here's the magic - using zero-knowledge cryptography, deposits and withdrawals cannot be linked.

Let me show you what I mean.

Before, with public transfers: Alice deposits one SOL. Later, Alice withdraws one SOL. Everyone can see that Alice put money in and Alice took money out. The link is obvious.

After, with our private pool: Alice deposits. Bob deposits. Carol deposits. Then someone withdraws. Someone else withdraws. Someone else withdraws.

Who withdrew? Could be anyone. There's no link between a deposit and a withdrawal. The connection is cryptographically hidden.

---

## The Building Blocks

To make this work, we need several cryptographic building blocks. Let me introduce them before we dive in.

First, commitments. When you deposit, instead of recording your public key, we record a hash. This hash hides your identity. It's like putting your deposit in a sealed envelope.

Second, nullifiers. These prevent double-spending. You can only withdraw once per deposit. But we track this without revealing which deposit you're withdrawing.

Third, Merkle trees. We need to prove your deposit exists in the pool. Merkle trees let us do this efficiently with minimal data.

Fourth, ZK circuits. This is where the magic happens. We prove everything - that we have a valid deposit, that we haven't spent it before - without revealing which deposit is ours.

And fifth, on-chain verification. We use Sunspot to verify these proofs directly on Solana. No trusted intermediary.

Each step of this tutorial adds one of these building blocks.

---

## The Accounts

Let me walk through the accounts our program uses. If you remember from escrow, Solana programs store state in accounts.

First, the Pool account. This is a PDA - Program Derived Address. It stores the Merkle root, which is a fingerprint of all deposits. It also tracks which deposit slot we're on. Think of it as the program's brain.

Second, the PoolVault. Another PDA. This one holds the actual SOL. We separate data from money - Pool stores information, Vault holds lamports. This is a common Solana pattern.

Third, the NullifierSet. Yet another PDA. This tracks which nullifiers have been used. When you withdraw, your nullifier goes here. If you try to withdraw again, we check this list and reject you.

Fourth, the Verifier program. This is special - it's a separate Solana program generated by Sunspot. Our program calls it via CPI to verify ZK proofs. The verification key is baked right into its code.

---

## The Privacy Journey

Here's the roadmap for what we're building.

Step one - Commitments. We'll replace public depositor addresses with cryptographic hashes.

Step two - Nullifiers. We'll add double-spend prevention that doesn't reveal which deposit.

Step three - Merkle Trees. We'll track deposits efficiently and enable membership proofs.

Step four - ZK Circuits. We'll understand the proof that ties everything together.

Step five - On-chain Verification. We'll deploy Sunspot and verify proofs on Solana.

Step six - Demo. We'll see the complete system working end to end.

---

## What Is Zero-Knowledge?

Before we dive in, let me explain zero-knowledge proofs at a high level.

A zero-knowledge proof lets you prove a statement is true without revealing the data that makes it true.

Here's a classic example. Imagine you want to prove you're over eighteen to buy alcohol. Normally, you'd show your ID. But your ID reveals your exact birthday, your address, maybe your photo.

With a zero-knowledge proof, you could prove "I am over eighteen" without revealing your actual age. The verifier is completely convinced you're of legal age, but they learn nothing else about you.

Another example - proving you're from a certain country without revealing all the information in your passport.

In our case, we'll prove "I made a valid deposit to this pool" without revealing which deposit it was. The blockchain verifier is convinced we have the right to withdraw, but learns nothing about our identity.

---

## Privacy Trade-offs

A few things to keep in mind as we build this.

First, anonymity set. Your privacy depends on how many other deposits exist. If you're the only depositor, well, it's obvious who's withdrawing. With a hundred deposits of similar amounts, observers have a one percent chance of guessing which one is yours. More deposits means more privacy.

Second, amount correlation. If you deposit exactly one-point-two-three-four-five-six-seven SOL and someone withdraws that exact amount, it might be obvious they're linked. This code handles variable amounts for flexibility, but fixed amounts - like always one SOL - provide stronger privacy.

This is educational code, not production code. But these principles apply to real privacy systems.

---

## Let's Build

Alright, enough theory. Let's start building.

Open the starter code and let's look at what we have.
