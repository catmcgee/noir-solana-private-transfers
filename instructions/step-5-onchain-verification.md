# Step 5: On-chain Verification

## Goal

Deploy the Sunspot verifier program and add CPI to verify ZK proofs on-chain.

## Where We Are

```
‚úÖ Step 0: Understand the architecture
‚úÖ Step 1: Hide deposit details
‚úÖ Step 2: Prove membership
‚úÖ Step 3: Prevent double-spending
‚úÖ Step 4: The ZK circuit
üî≤ Step 5: On-chain verification     ‚Üê You are here
```

---

## The Flow

Here's how verification fits into the withdrawal:

```
ON-CHAIN VERIFICATION:
1. Transaction arrives with proof + public inputs
2. Program checks nullifier not used (Step 2)
3. Program checks root is known (Step 3)
4. Program calls verifier via CPI                        <-- We add this
5. Verifier checks cryptographic equation
6. If valid: continue to transfer funds
7. If invalid: entire transaction fails (atomic)
```

The verifier is a separate Solana program generated by Sunspot. Our program calls it via CPI (Cross-Program Invocation).

---

## Deploy the Verifier

### Generate the Solana Verifier Program

```bash
# Generate Solana program from verification key
sunspot deploy --vk circuits/withdrawal/target/withdrawal.vk --output anchor/programs/verifier

# Build everything including the new verifier
cd anchor
anchor build

# Deploy to devnet
solana config set --url devnet
anchor deploy --provider.cluster devnet
```

**Important:** Copy the verifier program ID from the output!

```
Deploying program "verifier"...
Program Id: CU2Vgym4wiTNcJCuW6r7DV6bCGULJxKdwFjfGfmksSVZ
```

---

## Program Updates

### 1. Add imports and verifier ID

In `lib.rs`, find:

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::program::invoke;
use anchor_lang::system_program;

declare_id!("2QRZu5cWy8x8jEFc9nhsnrnQSMAKwNpiLpCXrMRb3oUn");

pub const TREE_DEPTH: usize = 10;
```

Replace with:

```rust
use anchor_lang::prelude::*;
use anchor_lang::solana_program::instruction::Instruction;
use anchor_lang::solana_program::program::invoke;
use anchor_lang::system_program;

declare_id!("2QRZu5cWy8x8jEFc9nhsnrnQSMAKwNpiLpCXrMRb3oUn");

// PASTE YOUR VERIFIER PROGRAM ID HERE!
pub const SUNSPOT_VERIFIER_ID: Pubkey = pubkey!("CU2Vgym4wiTNcJCuW6r7DV6bCGULJxKdwFjfGfmksSVZ");

pub const TREE_DEPTH: usize = 10;
```

**What's new:**
- `Instruction` import - needed to build the CPI call
- `SUNSPOT_VERIFIER_ID` - the address of your deployed verifier program

### 2. Add encode_public_inputs function

The verifier expects public inputs in a specific binary format (Gnark witness format).

Find:

```rust
// Step 5: Add encode_public_inputs function here

#[derive(Accounts)]
pub struct Initialize<'info> {
```

Replace with:

```rust
/// Encode public inputs in Gnark witness format for the Sunspot verifier
fn encode_public_inputs(
    root: &[u8; 32],
    nullifier_hash: &[u8; 32],
    recipient: &Pubkey,
    amount: u64,
) -> Vec<u8> {
    const NR_PUBLIC_INPUTS: u32 = 4;
    let mut inputs = Vec::with_capacity(12 + 128);

    // Gnark header (12 bytes)
    inputs.extend_from_slice(&NR_PUBLIC_INPUTS.to_be_bytes());  // 4 bytes: number of public inputs
    inputs.extend_from_slice(&0u32.to_be_bytes());              // 4 bytes: number of private inputs (0)
    inputs.extend_from_slice(&NR_PUBLIC_INPUTS.to_be_bytes());  // 4 bytes: repeated

    // Public inputs - ORDER MUST MATCH NOIR CIRCUIT!
    inputs.extend_from_slice(root);                  // 32 bytes
    inputs.extend_from_slice(nullifier_hash);        // 32 bytes
    inputs.extend_from_slice(recipient.as_ref());    // 32 bytes (Pubkey is 32 bytes)

    // Amount as 32-byte big-endian (ZK field element format)
    let mut amount_bytes = [0u8; 32];
    amount_bytes[24..32].copy_from_slice(&amount.to_be_bytes());  // u64 is 8 bytes, pad with zeros
    inputs.extend_from_slice(&amount_bytes);

    inputs  // Total: 12 + 128 = 140 bytes
}

#[derive(Accounts)]
pub struct Initialize<'info> {
```

**Why this format?**
- The header tells the verifier how many inputs to expect
- The order must match exactly how they're declared in the Noir circuit (`root`, `nullifier_hash`, `recipient`, `amount`)
- Each input is 32 bytes (field elements in ZK are 256-bit)

### 3. Add verifier program to Withdraw accounts

Find:

```rust
    /// CHECK: Validated in instruction logic
    #[account(mut)]
    pub recipient: UncheckedAccount<'info>,

    // Step 5: Add verifier_program account here

    pub system_program: Program<'info, System>,
}
```

Replace with:

```rust
    /// CHECK: Validated in instruction logic
    #[account(mut)]
    pub recipient: UncheckedAccount<'info>,

    /// CHECK: Constraint validates this is the real Sunspot verifier
    #[account(
        constraint = verifier_program.key() == SUNSPOT_VERIFIER_ID
            @ PrivateTransfersError::InvalidVerifier
    )]
    pub verifier_program: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}
```

**What this does:**
- `UncheckedAccount` - we just need the AccountInfo for CPI, no deserialization
- `constraint = ...` - ensures the passed account is actually our verifier, not a fake

### 4. Update withdraw function signature

Add the proof parameter.

Find:

```rust
    pub fn withdraw(
        ctx: Context<Withdraw>,
        // Step 5: Add proof: Vec<u8>
        nullifier_hash: [u8; 32],
        root: [u8; 32],
        recipient: Pubkey,
        amount: u64,
    ) -> Result<()> {
```

Replace with:

```rust
    pub fn withdraw(
        ctx: Context<Withdraw>,
        proof: Vec<u8>,
        nullifier_hash: [u8; 32],
        root: [u8; 32],
        recipient: Pubkey,
        amount: u64,
    ) -> Result<()> {
```

### 5. Add ZK proof verification via CPI

This is the core of privacy - we verify the ZK proof on-chain.

Find:

```rust
        require!(
            ctx.accounts.pool_vault.lamports() >= amount,
            PrivateTransfersError::InsufficientVaultBalance
        );

        // Step 5: Verify ZK proof via CPI

        // Mark nullifier as used BEFORE transfer (prevents reentrancy)
```

Replace with:

```rust
        require!(
            ctx.accounts.pool_vault.lamports() >= amount,
            PrivateTransfersError::InsufficientVaultBalance
        );

        // VERIFY ZK PROOF via CPI
        let public_inputs = encode_public_inputs(&root, &nullifier_hash, &recipient, amount);
        let instruction_data = [proof.as_slice(), public_inputs.as_slice()].concat();

        invoke(
            &Instruction {
                program_id: ctx.accounts.verifier_program.key(),
                accounts: vec![],
                data: instruction_data,
            },
            &[ctx.accounts.verifier_program.to_account_info()],
        )?;

        // Mark nullifier as used BEFORE transfer (prevents reentrancy)
```

**What each part does:**
- `encode_public_inputs(...)` - formats inputs for the verifier
- `[proof, public_inputs].concat()` - combines into single instruction data
- `invoke(...)` - calls the verifier program via CPI
- `accounts: vec![]` - verifier is stateless, needs no accounts
- If the proof is invalid, `invoke` returns an error and the whole transaction fails atomically

### 6. Add InvalidVerifier error

Find:

```rust
    #[msg("Nullifier set is full")]
    NullifierSetFull,
    // Step 5: Add InvalidVerifier
}
```

Replace with:

```rust
    #[msg("Nullifier set is full")]
    NullifierSetFull,
    #[msg("Invalid verifier program")]
    InvalidVerifier,
}
```

### Build and Deploy

```bash
anchor build
anchor deploy --provider.cluster devnet
```

---

## Compute Units

ZK verification uses ~1.4 million compute units. Solana's default is 200K.

The frontend must request extra compute units:

```typescript
import { ComputeBudgetProgram } from "@solana/web3.js";

// Add this instruction FIRST in your transaction
const computeBudgetIx = ComputeBudgetProgram.setComputeUnitLimit({
  units: 1_400_000
});

// Then your withdraw instruction
const tx = new Transaction()
  .add(computeBudgetIx)
  .add(withdrawIx);
```

---

## Test

```bash
anchor test --provider.cluster devnet
```

---

## What We Built

The complete verification flow:

1. User generates proof off-chain (backend)
2. Transaction includes 256-byte proof + public inputs
3. Program checks nullifier unused + root known
4. Program calls verifier via CPI
5. Verifier checks cryptographic equation
6. If valid: mark nullifier used, transfer funds
7. If invalid: entire transaction reverts

The blockchain sees a deposit (commitment) and a withdrawal (nullifier_hash). These cannot be linked.

---

## Next Step

Let's see everything working together in a demo.

Continue to [Step 6: Demo](./step-6-demo.md).
