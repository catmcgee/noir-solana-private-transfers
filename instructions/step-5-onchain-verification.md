# Step 5: On-chain Verification

## Goal

Deploy the Sunspot verifier program and add proof verification to withdrawals.

---

## The Concept

We have a ZK circuit that generates proofs (Step 4). But proofs are generated off-chain - the Solana program needs to verify them on-chain before releasing funds.

Verification uses a **verifier program** generated by Sunspot:
- The verification key from Step 4 is "baked into" this program
- It only accepts proofs generated from your specific circuit
- Verification uses elliptic curve pairings (~1.4M compute units)

Our program calls the verifier via **CPI (Cross-Program Invocation)**:

```
Our Program                    Verifier Program
     |                              |
     |-- proof + public inputs -->  |
     |                              | (checks pairing equation)
     |<---- success/failure --------|
     |
     v
Transfer funds (if valid)
```

If verification fails, the entire transaction reverts - no funds move.

---

## The Verification Flow

Here's how on-chain verification fits into withdrawal:

```
VERIFICATION FLOW:
1. Frontend sends proof + public inputs
2. Program checks nullifier unused (Step 3)
3. Program checks root is known (Step 2)
4. Program calls verifier via CPI → verifier checks the math  <-- We add this
5. If valid: transfer funds
6. If invalid: entire transaction fails
```

The verifier is a separate Solana program generated by Sunspot. Our program calls it via CPI (Cross-Program Invocation).

---

## Deploy the Verifier

First, generate and deploy the Sunspot verifier program.

### Generate the verifier from your verification key

```bash
sunspot deploy --vk circuits/withdrawal/target/withdrawal.vk --output anchor/programs/verifier
```

This creates a Solana program with the verification key baked in. The verifier will only accept proofs generated from your specific circuit.

### Build and deploy

```bash
cd anchor
anchor build
solana config set --url devnet
anchor deploy --provider.cluster devnet
```

**Copy the verifier program ID from the output:**

```
Deploying program "verifier"...
Program Id: Amugr8yL9EQVAgGwqds9gCmjzs8fh6H3wjJ3eB4pBhXV
```

You'll need this ID in the next step.

**ZK concept - What the verifier does:**
- The verifier checks a "pairing equation" using elliptic curve math
- If `e(A,B) * e(C,D) = e(E,F)` (roughly), the proof is valid
- This takes ~1.4M compute units on Solana
- The verification key is "baked in" - only proofs from this specific circuit will verify

---

## The Withdrawal Flow (With Verification)

Let's trace what happens when the frontend sends a withdrawal with a proof.

---

### 1. Backend Generates the Proof (READ)

**File:** `backend/src/server.ts` - find `/api/withdraw` endpoint

After computing the witness values, the backend generates a Groth16 proof:

```typescript
app.post("/api/withdraw", async (req, res) => {
  const { nullifier, secret, amount, leafIndex, recipient } = req.body

  // Write circuit inputs to Prover.toml
  await writeProverToml({
    root: merkleTree.root,
    nullifier_hash: poseidon2Hash([nullifier]),
    recipient: recipient,
    amount: amount,
    nullifier: nullifier,
    secret: secret,
    merkle_proof: merkleTree.getProof(leafIndex).siblings,
    is_even: merkleTree.getProof(leafIndex).pathIndices,
  })

  // Generate witness and proof
  await exec('nargo execute')
  await exec('sunspot prove')

  // Read the 256-byte proof
  const proof = await readFile('proof.bin')
```

The backend returns the proof to the frontend:

```typescript
  res.json({
    proof: Array.from(proof),  // ~256 bytes
    nullifierHash: nullifierHashBytes,
    merkleRoot: merkleRootBytes,
    amount: amount,
  })
})
```

---

### 2. Frontend Sends the Proof (READ)

**File:** `frontend/src/components/WithdrawSection.tsx` - in `handleWithdraw`

The frontend receives the proof and includes it in the transaction:

```typescript
  const { proof, nullifierHash, merkleRoot, amount } = await proofResponse.json()

  // Encode instruction data with the proof
  const dataEncoder = getWithdrawInstructionDataEncoder()
  const instructionData = dataEncoder.encode({
    proof: new Uint8Array(proof),              // ~256 bytes from backend
    nullifierHash: new Uint8Array(nullifierHash),
    root: new Uint8Array(merkleRoot),
    recipient: recipientAddress,
    amount: BigInt(amount),
  })
```

The frontend also needs to request extra compute units for verification:

```typescript
  // Groth16 verification needs ~1.4M compute units
  const computeBudgetIx = getSetComputeUnitLimitInstruction({
    units: 1_400_000
  })

  // Build transaction with compute budget FIRST
  const withdrawInstruction = { ... }
```

**Solana concept - Compute Budget:**
- Every Solana transaction has a compute unit limit (default: 200,000)
- ZK verification needs ~1.4M compute units
- We must request more via `setComputeUnitLimit` instruction
- This instruction must be FIRST in the transaction

The transaction goes to our program. Let's add verification...

---

### 3. Program Verifies the Proof (TYPE)

**File:** `anchor/programs/private_transfers/src/lib.rs`

This is where we add verification. The program:
1. Encodes public inputs in the format the verifier expects
2. Calls the verifier via CPI
3. If verification fails, the whole transaction fails

#### Add the verifier ID constant

Find (note: this is where you had Step 5 comments):

```rust
pub const TREE_DEPTH: usize = 10;
pub const MAX_LEAVES: u64 = 1 << TREE_DEPTH;
pub const ROOT_HISTORY_SIZE: usize = 10;
```

Add **before** it:

```rust
// PASTE YOUR VERIFIER PROGRAM ID HERE!
// This is the address of the Sunspot verifier we deployed
pub const SUNSPOT_VERIFIER_ID: Pubkey = pubkey!("Amugr8yL9EQVAgGwqds9gCmjzs8fh6H3wjJ3eB8pBhXV");
```

**Solana concept - pubkey! macro:**
- `pubkey!("...")` converts a base58 string to a `Pubkey` at compile time
- Hard-coding the verifier ID ensures only our verifier can be called
- Prevents malicious verifier substitution

#### Add the encode_public_inputs function

The verifier expects public inputs in a specific binary format (Gnark witness format).

Find:

```rust
// Step 5: Add encode_public_inputs function here

#[derive(Accounts)]
pub struct Initialize<'info> {
```

Replace with:

```rust
/// Encode public inputs in Gnark witness format for the Sunspot verifier
/// The verifier was generated by Sunspot and expects this exact format
fn encode_public_inputs(
    root: &[u8; 32],           // Merkle root (public input 1)
    nullifier_hash: &[u8; 32], // Nullifier hash (public input 2)
    recipient: &Pubkey,         // Recipient address (public input 3)
    amount: u64,                // Withdrawal amount (public input 4)
) -> Vec<u8> {
    const NR_PUBLIC_INPUTS: u32 = 4;              // We have 4 public inputs in our circuit
    let mut inputs = Vec::with_capacity(12 + 128); // Pre-allocate: 12 byte header + 4 * 32 byte inputs

    // ===== GNARK HEADER (12 bytes) =====
    // This is the Gnark witness format header - required by the verifier
    inputs.extend_from_slice(&NR_PUBLIC_INPUTS.to_be_bytes());  // 4 bytes: number of public inputs
    inputs.extend_from_slice(&0u32.to_be_bytes());              // 4 bytes: number of private inputs (0)
    inputs.extend_from_slice(&NR_PUBLIC_INPUTS.to_be_bytes());  // 4 bytes: total public inputs

    // ===== PUBLIC INPUTS (128 bytes) =====
    // ORDER MUST MATCH THE NOIR CIRCUIT DECLARATION!
    // In main.nr: fn main(root: pub Field, nullifier_hash: pub Field, recipient: pub Field, amount: pub Field, ...)
    inputs.extend_from_slice(root);                  // 32 bytes - Merkle root
    inputs.extend_from_slice(nullifier_hash);        // 32 bytes - Nullifier hash
    inputs.extend_from_slice(recipient.as_ref());    // 32 bytes - Recipient pubkey

    // Amount needs special handling: u64 -> 32-byte big-endian field element
    // ZK field elements are 256-bit, but amount is only 64-bit
    // We pad with leading zeros to make it 32 bytes
    let mut amount_bytes = [0u8; 32];
    amount_bytes[24..32].copy_from_slice(&amount.to_be_bytes());
    inputs.extend_from_slice(&amount_bytes);         // 32 bytes - Amount

    inputs  // Total: 12 + 128 = 140 bytes
}

#[derive(Accounts)]
pub struct Initialize<'info> {
```

**Why this exact order?**
- The order must match exactly how inputs are declared in the Noir circuit
- In `main.nr`: `fn main(root: pub Field, nullifier_hash: pub Field, recipient: pub Field, amount: pub Field, ...)`
- Wrong order = proof will fail verification

#### Add verifier to Withdraw accounts

Find:

```rust
    /// CHECK: Validated in instruction logic
    #[account(mut)]
    pub recipient: UncheckedAccount<'info>,

    // Step 5: Add verifier_program account here

    pub system_program: Program<'info, System>,
}
```

Replace with:

```rust
    /// CHECK: Validated in instruction logic
    #[account(mut)]
    pub recipient: UncheckedAccount<'info>,

    /// CHECK: Constraint below validates this is the real Sunspot verifier
    #[account(
        constraint = verifier_program.key() == SUNSPOT_VERIFIER_ID
            @ PrivateTransfersError::InvalidVerifier
    )]
    pub verifier_program: UncheckedAccount<'info>,

    pub system_program: Program<'info, System>,
}
```

**Solana concept - UncheckedAccount:**
- `UncheckedAccount<'info>` is a raw `AccountInfo` without Anchor deserialization
- Used when we don't need to read/write the account's data
- For CPI, we just need the program's address
- The `/// CHECK:` comment is required by Anchor

#### Update withdraw function signature

Find:

```rust
    pub fn withdraw(
        ctx: Context<Withdraw>,
        // Step 5: Add proof: Vec<u8>
        nullifier_hash: [u8; 32],
        root: [u8; 32],
        recipient: Pubkey,
        amount: u64,
    ) -> Result<()> {
```

Replace with:

```rust
    pub fn withdraw(
        ctx: Context<Withdraw>,
        proof: Vec<u8>,            // ~256 bytes - the Groth16 proof from backend
        nullifier_hash: [u8; 32],
        root: [u8; 32],
        recipient: Pubkey,
        amount: u64,
    ) -> Result<()> {
```

#### Add the verification CPI call

Find:

```rust
        require!(
            ctx.accounts.pool_vault.lamports() >= amount,
            PrivateTransfersError::InsufficientVaultBalance
        );

        // Step 5: Verify ZK proof via CPI

        // CRITICAL: Mark nullifier as used BEFORE transfer
```

Replace with:

```rust
        require!(
            ctx.accounts.pool_vault.lamports() >= amount,
            PrivateTransfersError::InsufficientVaultBalance
        );

        // ===== VERIFY ZK PROOF via CPI =====
        // This is the magic - we verify the proof without knowing the private inputs!

        // Step 1: Encode public inputs in the format the verifier expects
        let public_inputs = encode_public_inputs(&root, &nullifier_hash, &recipient, amount);

        // Step 2: Combine proof + public inputs into instruction data
        let instruction_data = [proof.as_slice(), public_inputs.as_slice()].concat();

        // Step 3: Call the verifier program via CPI
        invoke(
            &Instruction {
                program_id: ctx.accounts.verifier_program.key(),
                accounts: vec![],  // Verifier is stateless - no accounts needed
                data: instruction_data,
            },
            &[ctx.accounts.verifier_program.to_account_info()],
        )?;  // If verification fails, whole transaction reverts

        // CRITICAL: Mark nullifier as used BEFORE transfer
```

**Solana concept - invoke():**
- `invoke()` makes a CPI call to another program
- First argument: the instruction to execute
- Second argument: slice of AccountInfos
- The `?` propagates errors - if verifier fails, we fail

**What the verifier checks:**
- The verifier performs elliptic curve pairing operations
- It checks that the proof satisfies the circuit constraints
- If valid: the prover knows private inputs that produce these public outputs
- If invalid: the proof is forged or public inputs don't match

#### Add the imports at the top of the file

Make sure you have these imports:

```rust
use anchor_lang::solana_program::instruction::Instruction;
use anchor_lang::solana_program::program::invoke;
```

#### Add InvalidVerifier error

Find:

```rust
    #[msg("Nullifier set is full")]
    NullifierSetFull,
```

Add after it:

```rust
    #[msg("Invalid verifier program")]
    InvalidVerifier,
```

---

### Build and Deploy

```bash
cd anchor
anchor build
anchor deploy --provider.cluster devnet
```

---

## Compute Units Explained

ZK verification uses ~1.4 million compute units. Solana's default limit is 200K.

**Why 1.4M compute units?**
- Groth16 verification requires ~3 elliptic curve pairing operations
- Each pairing is ~400K compute units
- Plus overhead for encoding, CPI, account access
- If you run out of compute units, transaction fails with "exceeded CU limit"

The frontend requests extra compute units like this:

```typescript
import { getSetComputeUnitLimitInstruction } from "@solana-program/compute-budget"

const computeBudgetIx = getSetComputeUnitLimitInstruction({
  units: 1_400_000
})

// This instruction must be FIRST in the transaction
```

---

## What We Built

Complete withdrawal verification:

```
1. Backend generates proof (256 bytes, ~30 seconds)
2. Frontend sends proof + public inputs
3. Program validates nullifier not used
4. Program validates root is known
5. Program calls verifier via CPI
6. Verifier checks cryptographic equation
7. If valid: mark nullifier used, transfer funds
8. If invalid: entire transaction reverts
```

**Privacy achieved:**
- Blockchain sees: deposit (commitment) → withdrawal (nullifier_hash)
- These cannot be linked (different hash outputs)
- ZK proof convinces everyone it's valid
- But nobody knows which deposit was spent

---

## What's Next

The program is complete! Let's test everything end-to-end.

Continue to [Step 6: Demo](./step-6-demo.md).
