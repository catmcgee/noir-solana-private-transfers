# Step 0: Introduction

## From Escrow to Private Pool

In your escrow program, everything was transparent:

- The maker's deposit was visible onchain
- The taker's address was stored in the escrow account
- Anyone could see who traded with whom

Now let's make it private!

## What we're building

A **private pool** - similar tos an escrow, but with hidden participants:

```
BEFORE (Public):
Alice deposits 1 SOL  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º  Alice withdraws 1 SOL
     â”‚                                            â”‚
     â””â”€â”€â”€â”€ LINKED (everyone can see) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

AFTER (Private):
Alice deposits  â”€â”€â”€â”€â–º  [Pool]  â”€â”€â”€â”€â–º  ??? withdraws
Bob deposits    â”€â”€â”€â”€â–º  [Pool]  â”€â”€â”€â”€â–º  ??? withdraws
Carol deposits  â”€â”€â”€â”€â–º  [Pool]  â”€â”€â”€â”€â–º  ??? withdraws

No one can link deposits to withdrawals
```

![image](./assets/full_flow.png)

## The Accounts

Our private pool has four key accounts:

| Account          | Type    | Seeds                  | Purpose                                               |
| ---------------- | ------- | ---------------------- | ----------------------------------------------------- |
| **Pool**         | PDA     | `["pool"]`             | Stores Merkle root history, leaf index, deposit count |
| **PoolVault**    | PDA     | `["vault", pool]`      | Holds deposited SOL (like the escrow vault)           |
| **NullifierSet** | PDA     | `["nullifiers", pool]` | Tracks used nullifier hashes to prevent double-spend  |
| **Verifier**     | Program | N/A                    | Sunspot-generated program that verifies ZK proofs     |

**Pool** - The main state account. Instead of storing maker/taker like escrow, it stores:

- `roots`: A ring buffer of recent Merkle roots (allows timing flexibility for proofs)
- `next_leaf_index`: Which slot the next deposit goes into
- `current_root_index`: Points to the newest root

**PoolVault** - Holds the actual SOL. It's a separate PDA so the program can sign transfers out using `invoke_signed`.

**NullifierSet** - Prevents double-spending. When you withdraw, your `nullifier_hash` is added here. Future withdrawals check this list.

**Verifier** - A separate Solana program generated by Sunspot. Contains the verification key baked in. Our program calls it via CPI to verify ZK proofs.

## Lets go!

The starter code implements a basic SOL pool.

```bash
cd anchor
anchor build
```

You should see the program compile.

### The code

Open `anchor/programs/private_transfers/src/lib.rs`. The structure should look familiar from your escrow:

```rust
pub fn deposit(
    ctx: Context<Deposit>,
    amount: u64,
) -> Result<()> {
    // Transfer SOL to vault
    // ...
    emit!(DepositEvent {
        depositor: ctx.accounts.depositor.key(),  // Everyone sees WHO deposited
        amount,                                    // Everyone sees HOW MUCH
    });
    Ok(())
}
```

> ðŸ’¡ **Solana Reminder**: `emit!` creates program logs that indexers can read. In your escrow, you might have emitted events when trades completed. Here we emit on deposit/withdraw.

And the withdraw function:

```rust
pub fn withdraw(
    ctx: Context<Withdraw>,
    recipient: Pubkey,
    amount: u64,
) -> Result<()> {
    // Transfer from vault PDA
    // ...
    emit!(WithdrawEvent {
        recipient: ctx.accounts.recipient.key(),  // Everyone sees WHO withdrew
        amount,
    });
    Ok(())
}
```

## The Privacy journey

Over the next steps, you'll transform this public pool into a private one:

| Step | What You'll Add      | Problem It Solves                                    |
| ---- | -------------------- | ---------------------------------------------------- |
| 1    | Commitments          | Hide deposit details                                 |
| 2    | Nullifiers           | Prevent double-spend without revealing which deposit |
| 3    | Merkle Trees         | Efficiently prove deposit exists                     |
| 4    | ZK Circuits          | Prove everything without revealing anything          |
| 5    | onchain Verification | Trustlessly verify proofs on Solana                  |

![image](./assets/before_after_privacy.png)

Zero-knowledge proofs let you prove a statement is true without revealing the data that makes it true.

A classic example is being able to prove you are from a certain country without revealing all the under information in your passport, or that you are over 18 without revealing your age.

## Things to be aware of

**Anonymity Set**: Your privacy depends on how many other deposits exist. For example, with 100 deposits of similar amounts, observers have a 1% chance of guessing which deposit is yours.

**Amount Correlation**: If you deposit 1.234567 SOL and someone withdraws 1.234567 SOL, it might be obvious they are linked. This code goes over variable transfers, but fixed are sometimes better.

## What You'll Learn

| Step | ZK Concept                                   | Solana Concept                         |
| ---- | -------------------------------------------- | -------------------------------------- |
| 1    | Commitments (hiding data in hashes)          | offchain hashing, Poseidon constraints |
| 2    | Nullifiers (private double-spend prevention) | Vec storage, account sizing            |
| 3    | Merkle trees (efficient membership proofs)   | Root history, ring buffers             |
| 4    | ZK circuits (prove without revealing)        | Groth16 on Solana, Sunspot             |
| 5    | onchain verification                         | CPI to verifier, compute budget        |

## Next Step

Continue to [Step 1: Commitments](./step-1-commitments.md).
